// Generated by CoffeeScript 1.7.1
var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

define(['jquery', 'external/react', 'modules/clean/avatar/size', 'modules/clean/avatar/style', 'modules/clean/react/image', 'modules/core/exception', 'modules/core/uri'], function($j, React, _arg, _arg1, Image, JSException, URI) {
  var AvatarWithDefault, Faceholder, InitialsAvatar, InitialsAvatarWithColorDerivedFromName, OverflowCountPill, PhotoAvatar, SharedLinkAvatar, VALID_AVATAR_DIMENSIONS, ViewerAvatar, d, dynamicInlineStyle, getClassName, hsl_color_value_for_avatar_name;
  VALID_AVATAR_DIMENSIONS = _arg.VALID_AVATAR_DIMENSIONS;
  hsl_color_value_for_avatar_name = _arg1.hsl_color_value_for_avatar_name;
  d = React.DOM;
  dynamicInlineStyle = function(dimension, shape) {
    var borderRadius;
    if (shape == null) {
      shape = 'CIRCLE';
    }
    JSException.assert(__indexOf.call(VALID_AVATAR_DIMENSIONS, dimension) >= 0, "`dimension` must be one of: [" + VALID_AVATAR_DIMENSIONS + "]");
    JSException.assert(shape === 'CIRCLE' || shape === 'SQUARE', "`shape` must be one of ['CIRCLE', 'SQUARE']");
    if (shape === 'SQUARE') {
      borderRadius = (function() {
        switch (false) {
          case !(dimension < 32):
            return '2px';
          case dimension !== 32:
            return '3px';
          default:
            return '4px';
        }
      })();
    } else {
      borderRadius = '50%';
    }
    return {
      width: dimension,
      height: dimension,
      fontSize: "" + (Math.ceil(dimension * 0.4)) + "px",
      fontWeight: (function() {
        switch (false) {
          case !(dimension < 32):
            return 700;
          case !(dimension < 48):
            return 600;
          default:
            return 400;
        }
      })(),
      borderRadius: borderRadius
    };
  };
  getClassName = function(classes) {
    if (classes == null) {
      classes = [];
    }
    classes.push('avatar-component');
    return React.addons.classSet.apply(this, classes);
  };
  OverflowCountPill = React.createClass({
    propTypes: {
      dimension: React.PropTypes.oneOf(VALID_AVATAR_DIMENSIONS).isRequired,
      count: React.PropTypes.number.isRequired,
      onClick: React.PropTypes.func
    },
    render: function() {
      return d.div({
        className: getClassName(['overflow-pill']),
        onClick: this.props.onClick,
        style: this.getStyle()
      }, "+" + this.props.count);
    },
    getStyle: function() {
      var borderRadius, height, style;
      style = dynamicInlineStyle(this.props.dimension);
      delete style.width;
      delete style.borderRadius;
      height = "" + this.props.dimension + "px";
      style.minWidth = style.lineHeight = height;
      borderRadius = "" + (this.props.dimension / 2) + "px";
      style.borderRadius = style.WebkitBorderRadius = style.MozBorderRadius = borderRadius;
      style.padding = "0 " + (Math.ceil(0.15 * this.props.dimension)) + "px";
      return style;
    }
  });
  Faceholder = React.createClass({
    propTypes: {
      dimension: React.PropTypes.oneOf(VALID_AVATAR_DIMENSIONS).isRequired,
      faceholderStaticImgUrls: React.PropTypes.object,
      onClick: React.PropTypes.func
    },
    componentDidMount: function() {
      if (this.props.faceholderStaticImgUrls != null) {
        return Image.addStaticUrls(this.props.faceholderStaticImgUrls);
      }
    },
    render: function() {
      return d.div({
        className: getClassName(['circle']),
        onClick: this.props.onClick,
        style: dynamicInlineStyle(this.props.dimension, 'CIRCLE')
      }, Image({
        src: "avatar/faceholder-" + this.props.dimension + ".png"
      }));
    }
  });
  SharedLinkAvatar = React.createClass({
    propTypes: {
      dimension: React.PropTypes.oneOf(VALID_AVATAR_DIMENSIONS).isRequired,
      sharedLinkStaticImgUrls: React.PropTypes.object,
      onClick: React.PropTypes.func
    },
    componentDidMount: function() {
      if (this.props.sharedLinkStaticImgUrls != null) {
        return Image.addStaticUrls(this.props.sharedLinkStaticImgUrls);
      }
    },
    render: function() {
      return d.div({
        className: getClassName(['circle', 'shared-link']),
        onClick: this.props.onClick,
        style: dynamicInlineStyle(this.props.dimension)
      });
    }
  });
  InitialsAvatar = React.createClass({
    propTypes: {
      dimension: React.PropTypes.oneOf(VALID_AVATAR_DIMENSIONS).isRequired,
      initials: React.PropTypes.string.isRequired,
      shape: React.PropTypes.oneOf(['CIRCLE', 'SQUARE']).isRequired,
      color: React.PropTypes.string,
      onClick: React.PropTypes.func
    },
    render: function() {
      return d.div({
        className: getClassName(['initials', this.props.shape.toLowerCase()]),
        onClick: this.props.onClick,
        style: this.getContainerStyle()
      }, this.props.initials);
    },
    getContainerStyle: function() {
      var style;
      style = dynamicInlineStyle(this.props.dimension, this.props.shape);
      style.lineHeight = "" + (this.props.dimension - 4) + "px";
      if (this.props.color) {
        style.color = this.props.color;
        style.borderColor = this.props.color;
      }
      return style;
    }
  });
  InitialsAvatarWithColorDerivedFromName = React.createClass({
    propTypes: {
      name: React.PropTypes.string.isRequired
    },
    render: function() {
      var new_props;
      new_props = $j.extend({
        color: hsl_color_value_for_avatar_name(this.props.name)
      }, this.props);
      delete new_props.name;
      return new InitialsAvatar(new_props);
    }
  });
  PhotoAvatar = React.createClass({
    propTypes: {
      dimension: React.PropTypes.oneOf(VALID_AVATAR_DIMENSIONS).isRequired,
      photoUrl: React.PropTypes.string.isRequired,
      onClick: React.PropTypes.func
    },
    render: function() {
      return d.div({
        className: getClassName(['photo', 'circle']),
        onClick: this.props.onClick,
        style: dynamicInlineStyle(this.props.dimension, 'CIRCLE')
      }, d.img({
        src: this.props.photoUrl,
        width: this.props.dimension,
        height: this.props.dimension
      }));
    }
  });
  AvatarWithDefault = React.createClass({
    propTypes: {
      dimension: React.PropTypes.oneOf(VALID_AVATAR_DIMENSIONS).isRequired,
      defaultAvatar: React.PropTypes.element.isRequired,
      onPhotoClick: React.PropTypes.func,
      photoUrl: React.PropTypes.string
    },
    render: function() {
      if (this.props.photoUrl != null) {
        return new PhotoAvatar({
          dimension: this.props.dimension,
          onClick: this.props.onPhotoClick,
          photoUrl: this.props.photoUrl
        });
      } else {
        return this.props.defaultAvatar;
      }
    }
  });
  ViewerAvatar = React.createClass({
    propTypes: {
      dimension: React.PropTypes.oneOf(VALID_AVATAR_DIMENSIONS).isRequired,
      defaultAvatar: React.PropTypes.element.isRequired,
      onPhotoClick: React.PropTypes.func,
      photoUrl: React.PropTypes.string
    },
    getInitialState: function() {
      return {
        photoUrl: this.props.photoUrl
      };
    },
    componentDidMount: function() {
      $j(document).on('db:accountphoto:photo_set', (function(_this) {
        return function(e, data) {
          var dimension2x, photoUrl, size;
          dimension2x = _this.props.dimension * 2;
          size = "" + dimension2x + "x" + dimension2x;
          photoUrl = URI.parse(data.saved_photo_url).updateQuery({
            size: size
          }).toString();
          return _this.setState({
            photoUrl: photoUrl
          });
        };
      })(this));
      return $j(document).on('db:accountphoto:photo_deleted', (function(_this) {
        return function(e) {
          return _this.setState({
            photoUrl: null
          });
        };
      })(this));
    },
    render: function() {
      if (this.state.photoUrl != null) {
        return new PhotoAvatar({
          dimension: this.props.dimension,
          onClick: this.props.onPhotoClick,
          photoUrl: this.state.photoUrl
        });
      } else {
        return this.props.defaultAvatar;
      }
    }
  });
  return {
    AvatarWithDefault: AvatarWithDefault,
    InitialsAvatar: InitialsAvatar,
    InitialsAvatarWithColorDerivedFromName: InitialsAvatarWithColorDerivedFromName,
    OverflowCountPill: OverflowCountPill,
    PhotoAvatar: PhotoAvatar,
    ViewerAvatar: ViewerAvatar,
    Faceholder: Faceholder,
    SharedLinkAvatar: SharedLinkAvatar
  };
});

//# sourceMappingURL=components.map
