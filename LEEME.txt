#
# Proyecto Traductores
# 
# Integrantes:
# 	Andres Navarro      11-10688
# 	Marisela Del Valle  11-10217
#
# Fecha Ultima Modificacion: 
# 	14/06/2015

##LEEME##

Implementacion :
	Lenguaje de programacion : Ruby 1.9
	Archivos :  lanscii (main) #Ejecutable ./lanscii <nombreArchivoIn>
				Lexer.rb
				Token.rb
				InvalidWord.rb
				Gramatica.txt
				Parser.y
				Parser.rb
				Clases.rb
				FuncionesDeTablas.rb
				Table.rb
				TableSymbol.rb

Estado actual :
	Actualmente el proyecto lee un archivo de entrada, detecta los simbolos que el lenguaje Lanscii acepta y devuelve los tokens correspondientes. Si todos los simbolos son aceptados, Se ejecuta el Parser tomando como parametro de entrada y se crea el arbol sintactico abstracto respectivo. Luego se crea una tabla de s√≠mbolos con las declaraciones correspondientes (variable y tipo), y se imprime por pantalla.

Problemas presentes : 
	Presenta problemas cuando se leen varias expresiones relacionales consecutivas, a menos que las expresiones esten parentizadas. De resto esta todo bien.

Comentarios adicionales : 
	
	1) Los caracteres inesperados, en el caso de no estar contenidos en un comentario, son tomados uno por uno para evitar posibles combinaciones de caracteres validos con inesperados. Ejemplo "\=\;" , nuestro analizador lexicografico analiza primero "\", despues el "=", luego el "\" y por ultimo ";".

	2) Todos lo numeros enteros son convertidos en token por nuestro analizador lexicografico. La restriccion numero menor de 32 bits con signo sera tomado en cuenta mas adelante.

	3) Al atrapar el error de parseo, aparece el mensaje "Syntax error:" seguido del error encontrado. No se especifica mas nada ya que no es especificado en el enunciado.

	4) Por ejemplo, si tenemos el caso: 'write 5+true' primero evalua la expresion del write (5+true), determinando que no se puede sumar 5 con true, y luego que no se puede escribir una expresion que no sea de tipo lienzo (evalua desde lo mas interno a lo externo)

	5) Al recorrer el codigo, se va creando la tabla. Si no consigue errores, sigue buscando bloques internos. En caso de conseguir error en un siguiente bloque, imprime los errores correspondientes y finaliza el programa.